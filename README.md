# NavStackLab

This is an example program that demonstrates the use of NavigationStack and NavigationPath, both introduced in iOS 16. The core idea of the interaction of these two is that a NavagationStack (which represents a stack of views that can be pushed onto or popped from, similar to UINavigationController) can be bound to a property containing a NavigationPath (which contains a collection of objects, each of which is typically some sort of model object that is the core component of each view on the stack). To add a new view to a NavigationStack, you just need to append an object to the NavigationPath that it's bound to, ensuring first that the NavigationStack has declared a view that corresponds to that object's type by using `.navigationDestination(for:)`.

In this example, the top-level navigation of the app is a TabView. Inside each of the content views is a NavigationStack, and each of those is bound to a specific NavigationPath. The NavigationPaths are all owned by a custom class called AppRouter, which also contains a property that is bound to the selection state of the TabView. This setup means that we can control the entire app navigation through AppRouter, by setting the appropriate values. To provide a concise way of doing this, there's also a struct called AppRoute that represents the "target" that you might want to navigate to. One can simply pass an AppRoute to the AppRouter through its `forceNavigate(to:)` method, and it will adjust the current selected tab and its associated NavigationPath, which through bindings will update the views. This is something you'll probably want to do when handling inbound URLs containing deep links, for example. Some example usages can be found in RootTabView, where enabling any of those commented-out AppRoute instantiations will force the app to navigate to a specific spot when it launches.
